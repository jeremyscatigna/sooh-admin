{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla/utils.mjs", "../../jotai/esm/react/utils.mjs"],
  "sourcesContent": ["import { atom } from 'jotai/vanilla';\n\nconst RESET = Symbol();\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, action) => set(anAtom, reducer(get(anAtom), action))\n  );\n  return anAtom;\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove)\n      return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$4 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$4, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = atom((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        if (value instanceof Promise || prev instanceof Promise) {\n          return Promise.all([value, prev]).then(selectValue);\n        }\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo1$1 = (create, dep1) => (cache1$3.has(dep1) ? cache1$3 : cache1$3.set(dep1, create())).get(dep1);\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null)\n    return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  return memo1$1(() => {\n    const frozenAtom = atom(\n      (get) => deepFreeze(get(anAtom)),\n      (_get, set, arg) => set(anAtom, arg)\n    );\n    return frozenAtom;\n  }, anAtom);\n}\nfunction freezeAtomCreator(createAtom) {\n  return (...params) => {\n    const anAtom = createAtom(...params);\n    const origRead = anAtom.read;\n    anAtom.read = function(get, options) {\n      return deepFreeze(origRead.call(this, get, options));\n    };\n    return anAtom;\n  };\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = atom((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? atom(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : atom((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        set(overwrittenAtom, EMPTY);\n      } else if (typeof update === \"function\") {\n        const prevValue = get(anAtom);\n        set(overwrittenAtom, update(prevValue));\n      } else {\n        set(overwrittenAtom, update);\n      }\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction createJSONStorage(getStringStorage) {\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2);\n          } catch {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a = getStringStorage()) == null ? void 0 : _a.getItem(key)) != null ? _b : null;\n      if (isPromiseLike(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.setItem(key, JSON.stringify(newValue));\n    },\n    removeItem: (key) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.removeItem(key);\n    }\n  };\n  if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    storage.subscribe = (key, callback, initialValue) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          let newValue;\n          try {\n            newValue = JSON.parse(e.newValue || \"\");\n          } catch {\n            newValue = initialValue;\n          }\n          callback(newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage(\n  () => typeof window !== \"undefined\" ? window.localStorage : void 0\n);\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, unstable_options) {\n  const getOnInit = unstable_options == null ? void 0 : unstable_options.unstable_getOnInit;\n  const baseAtom = atom(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    if (!getOnInit) {\n      setAtom(storage.getItem(key, initialValue));\n    }\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (nextValue instanceof Promise) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (result instanceof Promise) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!(value instanceof Promise)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached = loadableCache.get(promise);\n        if (cached) {\n          return cached;\n        }\n        loadableCache.set(promise, LOADING);\n        promise.then(\n          (data) => {\n            loadableCache.set(promise, { state: \"hasData\", data });\n          },\n          (error) => {\n            loadableCache.set(promise, { state: \"hasError\", error });\n          }\n        ).finally(setSelf);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = atom(0);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = atom(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!(promise instanceof Promise)) {\n            return { v: promise };\n          }\n          if (promise === (prev == null ? void 0 : prev.p)) {\n            if (promiseErrorCache.has(promise)) {\n              throw promiseErrorCache.get(promise);\n            }\n            if (promiseResultCache.has(promise)) {\n              return {\n                p: promise,\n                v: promiseResultCache.get(promise)\n              };\n            }\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            promise.then(\n              (v) => promiseResultCache.set(promise, v),\n              (e) => promiseErrorCache.set(promise, e)\n            ).finally(setSelf);\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v) };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return atom(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"v\" in state) {\n            return state.v;\n          }\n          return state.f;\n        },\n        (_get, set, ...args) => set(anAtom, ...args)\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithObservable, atomWithReducer, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, unwrap };\n", "import { useCallback, useMemo } from 'react';\nimport { useSetAtom, useAtom, useStore } from 'jotai/react';\nimport { RESET } from 'jotai/vanilla/utils';\nimport { atom } from 'jotai/vanilla';\n\nfunction useResetAtom(anAtom, options) {\n  const setAtom = useSetAtom(anAtom, options);\n  const resetAtom = useCallback(() => setAtom(RESET), [setAtom]);\n  return resetAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, options) {\n  const [state, setState] = useAtom(anAtom, options);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction useAtomCallback(callback, options) {\n  const anAtom = useMemo(\n    () => atom(null, (get, set, ...args) => callback(get, set, ...args)),\n    [callback]\n  );\n  return useSetAtom(anAtom, options);\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, options) {\n  const store = useStore(options);\n  const hydratedSet = getHydratedSet(store);\n  for (const [atom, value] of values) {\n    if (!hydratedSet.has(atom) || (options == null ? void 0 : options.dangerouslyForceHydrate)) {\n      hydratedSet.add(atom);\n      store.set(atom, value);\n    }\n  }\n}\nconst getHydratedSet = (store) => {\n  let hydratedSet = hydratedMap.get(store);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(store, hydratedSet);\n  }\n  return hydratedSet;\n};\n\nexport { useAtomCallback, useHydrateAtoms, useReducerAtom, useResetAtom };\n"],
  "mappings": "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",
  "names": ["atom"]
}
